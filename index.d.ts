/*!
 * @lottie-animation-community/lottie-types - v0.0.0
 * Compiled Tue, 13 Sep 2022 07:20:39 UTC
 *
 * Generated by an automated process. DO NOT EDIT!
 *
 * Copyright 2022 Lottie Animation Community.
 *
 * Licensed under the MIT License,
 * You may obtain a copy of the License at:
 * https://github.com/lottie-animation-community/lottie-types/blob/main/LICENSE
 *
 * Type definitions for the Lottie animation format.
 * Definitions by: Aidos Sabit <https://github.com/aidosmf>.
 *
 * To report an issue with these types, please open a support ticket at:
 * https://github.com/lottie-animation-community/lottie-types/issues
 */
declare namespace BlendMode {
  /**
   * Layer and shape blend mode
   */
  type Value =
    | Normal
    | Multiply
    | Screen
    | Overlay
    | Darken
    | Lighten
    | ColorDodge
    | ColorBurn
    | HardLight
    | SoftLight
    | Difference
    | Exclusion
    | Hue
    | Saturation
    | Color
    | Luminosity;

  type Normal = 0;
  type Multiply = 1;
  type Screen = 2;
  type Overlay = 3;
  type Darken = 4;
  type Lighten = 5;
  type ColorDodge = 6;
  type ColorBurn = 7;
  type HardLight = 8;
  type SoftLight = 9;
  type Difference = 10;
  type Exclusion = 11;
  type Hue = 12;
  type Saturation = 13;
  type Color = 14;
  type Luminosity = 15;

  const enum VALUE {
    NORMAL = 0,
    MULTIPLY = 1,
    SCREEN = 2,
    OVERLAY = 3,
    DARKEN = 4,
    LIGHTEN = 5,
    COLOR_DODGE = 6,
    COLOR_BURN = 7,
    HARD_LIGHT = 8,
    SOFT_LIGHT = 9,
    DIFFERENCE = 10,
    EXCLUSION = 11,
    HUE = 12,
    SATURATION = 13,
    COLOR = 14,
    LUMINOSITY = 15,
  }
}

declare namespace Composite {
  /**
   * How to stack copies in a repeater
   */
  type Value = Above | Below;

  type Above = 1;
  type Below = 2;

  const enum VALUE {
    ABOVE = 1,
    BELOW = 2,
  }
}

declare namespace EffectValueType {
  type Value =
    | Checkbox
    | Color
    | Dropdown
    | Ignored
    | Layer
    | Point
    | Slider
    | Angle;

  type Checkbox = 4;
  type Color = 2;
  type Dropdown = 7;
  type Ignored = 6;
  type Layer = 10;
  type Point = 3;
  type Slider = 0;
  type Angle = 1;

  const enum VALUE {
    CHECKBOX = 4,
    COLOR = 2,
    DROPDOWN = 7,
    IGNORED = 6,
    LAYER = 10,
    POINT = 3,
    SLIDER = 0,
    ANGLE = 1,
  }
}

declare namespace EffectType {
  type Value =
    | DropShadow
    | Fill
    | GaussianBlur
    | Matte3
    | ProLevels
    | Stroke
    | Tint
    | Tritone
    | RadialWipe
    | Wavy
    | Puppet
    | Spherize
    | PaintOverTransparent
    | MeshWarp
    | DisplacementMap
    | Custom;

  type DropShadow = 25;
  type Fill = 21;
  type GaussianBlur = 29;
  type Matte3 = 28;
  type ProLevels = 24;
  type Stroke = 22;
  type Tint = 20;
  type Tritone = 23;
  type RadialWipe = 26;
  type Wavy = 32;
  type Puppet = 34;
  type Spherize = 33;
  type PaintOverTransparent = 7;
  type MeshWarp = 31;
  type DisplacementMap = 27;
  type Custom = 5;

  const enum VALUE {
    DROP_SHADOW = 25,
    FILL = 21,
    GAUSSIAN_BLUR = 29,
    MATTE3 = 28,
    PRO_LEVELS = 24,
    STROKE = 22,
    TINT = 20,
    TRITONE = 23,
    RADIAL_WIPE = 26,
    WAVY = 32,
    PUPPET = 34,
    SPHERIZE = 33,
    PAINT_OVER_TRANSPARENT = 7,
    MESH_WARP = 31,
    DISPLACEMENT_MAP = 27,
    CUSTOM = 5,
  }
}

declare namespace FillRule {
  /**
   * Rule used to handle multiple shapes rendered with the same fill object
   */
  type Value = NonZero | EvenOdd;

  type NonZero = 1;
  type EvenOdd = 2;

  const enum VALUE {
    NON_ZERO = 1,
    EVEN_ODD = 2,
  }
}

declare namespace GradientType {
  /**
   * Type of a gradient
   *
   * @default 1
   */
  type Value = Linear | Radial;

  type Linear = 1;
  type Radial = 2;

  const enum VALUE {
    LINEAR = 1,
    RADIAL = 2,
  }
}

declare namespace LayerType {
  type Value =
    | Precomposition
    | SolidColor
    | Image
    | Null
    | Shape
    | Text
    | Audio
    | VideoPlaceholder
    | ImageSequence
    | Video
    | ImagePlaceholder
    | Guide
    | Adjustment
    | Camera
    | Light
    | Data;

  type Precomposition = 0;
  type SolidColor = 1;
  type Image = 2;
  type Null = 3;
  type Shape = 4;
  type Text = 5;
  type Audio = 6;
  type VideoPlaceholder = 7;
  type ImageSequence = 8;
  type Video = 9;
  type ImagePlaceholder = 10;
  type Guide = 11;
  type Adjustment = 12;
  type Camera = 13;
  type Light = 14;
  type Data = 15;

  const enum VALUE {
    PRECOMPOSITION = 0,
    SOLID_COLOR = 1,
    IMAGE = 2,
    NULL = 3,
    SHAPE = 4,
    TEXT = 5,
    AUDIO = 6,
    VIDEO_PLACEHOLDER = 7,
    IMAGE_SEQUENCE = 8,
    VIDEO = 9,
    IMAGE_PLACEHOLDER = 10,
    GUIDE = 11,
    ADJUSTMENT = 12,
    CAMERA = 13,
    LIGHT = 14,
    DATA = 15,
  }
}

declare namespace LineCap {
  /**
   * Style at the end of a stoked line
   */
  type Value = Butt | Round | Square;

  type Butt = 1;
  type Round = 2;
  type Square = 3;

  const enum VALUE {
    BUTT = 1,
    ROUND = 2,
    SQUARE = 3,
  }
}

declare namespace LineJoin {
  /**
   * Style at a sharp corner of a stoked line
   */
  type Value = Miter | Round | Bevel;

  type Miter = 1;
  type Round = 2;
  type Bevel = 3;

  const enum VALUE {
    MITER = 1,
    ROUND = 2,
    BEVEL = 3,
  }
}

declare namespace MaskMode {
  /**
   * How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html
   */
  type Value = No | Add | Subtract | Intersect | Lighten | Darken | Difference;

  type No = "n";
  type Add = "a";
  type Subtract = "s";
  type Intersect = "i";
  type Lighten = "l";
  type Darken = "d";
  type Difference = "f";

  const enum VALUE {
    NO = "n",
    ADD = "a",
    SUBTRACT = "s",
    INTERSECT = "i",
    LIGHTEN = "l",
    DARKEN = "d",
    DIFFERENCE = "f",
  }
}

declare namespace MatteMode {
  /**
   * How a layer should mask another layer
   */
  type Value = Normal | Alpha | InvertedAlpha | Luma | InvertedLuma;

  type Normal = 0;
  type Alpha = 1;
  type InvertedAlpha = 2;
  type Luma = 3;
  type InvertedLuma = 4;

  const enum VALUE {
    NORMAL = 0,
    ALPHA = 1,
    INVERTED_ALPHA = 2,
    LUMA = 3,
    INVERTED_LUMA = 4,
  }
}

declare namespace PolyStarType {
  /**
   * Star type, `1` for Star, `2` for Polygon
   */
  type Value = Star | Polygon;

  type Star = 1;
  type Polygon = 2;

  const enum VALUE {
    STAR = 1,
    POLYGON = 2,
  }
}

declare namespace ShapeDirection {
  /**
   * Drawing direction of the shape curve, useful for trim path
   */
  type Value = Normal | Clockwise | ClockwiseReversed;

  /**
   * Default Clockwise
   */
  type Normal = 0;

  /**
   * Usually clockwise
   */
  type Clockwise = 1;

  /**
   * Usually counter clockwise
   */
  type ClockwiseReversed = 3;

  const enum VALUE {
    NORMAL = 0,
    CLOCKWISE = 1,
    CLOCKWISE_REVERSED = 3,
  }
}

declare namespace ShapeType {
  type Value =
    | Rectangle
    | Ellipse
    | PolygonStar
    | Path
    | Fill
    | Stroke
    | GradientFill
    | GradientStroke
    | Group
    | Transform
    | RoundedCorners
    | PuckerBloat
    | Merge
    | Twist
    | OffsetPath
    | ZigZag
    | Modifier
    | Repeater
    | Trim;

  type Rectangle = "rc";
  type Ellipse = "el";
  type PolygonStar = "sr";
  type Path = "sh";
  type Fill = "fl";
  type Stroke = "st";
  type GradientFill = "gf";
  type GradientStroke = "gs";
  type Group = "gr";
  type Transform = "tr";
  type RoundedCorners = "rd";
  type PuckerBloat = "pb";
  type Merge = "mm";
  type Twist = "tw";
  type OffsetPath = "op";
  type ZigZag = "zz";
  type Modifier = ""; // null
  type Repeater = "rp";
  type Trim = "tm";

  const enum VALUE {
    RECTANGLE = "rc",
    ELLIPSE = "el",
    POLYGON_STAR = "sr",
    PATH = "sh",
    FILL = "fl",
    STROKE = "st",
    GRADIENT_FILL = "gf",
    GRADIENT_STROKE = "gs",
    GROUP = "gr",
    TRANSFORM = "tr",
    ROUNDED_CORNERS = "rd",
    PUCKER_BLOAT = "pb",
    MERGE = "mm",
    TWIST = "tw",
    OFFSET_PATH = "op",
    ZIG_ZAG = "zz",
    MODIFIER = "", // null
    REPEATER = "rp",
    TRIM = "tm",
  }
}

declare namespace StrokeDashType {
  /**
   * Type of a dash item in a stroked line
   */
  type Value = Default | Gap | Offset;

  type Default = "d";
  type Gap = "g";
  type Offset = "o";

  const enum VALUE {
    DEFAULT = "d",
    GAP = "g",
    OFFSET = "o",
  }
}

declare namespace TextType {
  type Based = Characters | CharacterExcludingSpaces | Words | Lines;
  type Characters = 1;
  type CharacterExcludingSpaces = 2;
  type Words = 3;
  type Lines = 4;

  const enum BASED {
    CHARACTERS = 1,
    CHARACTER_EXCLUDING_SPACES = 2,
    WORDS = 3,
    LINES = 4,
  }

  /**
   * @default 0
   */
  type Caps = Regular | AllCaps | SmallCaps;
  type Regular = 0;
  type AllCaps = 1;
  type SmallCaps = 2;

  const enum TEXT_CAPS {
    REGULAR = 0,
    ALL_CAPS = 1,
    SMALL_CAPS = 2,
  }

  type Grouping = Characters | Word | Line | All;
  type Word = 2;
  type Line = 3;
  type All = 4;

  const enum GROUPING {
    CHARACTERS = 1,
    WORD = 2,
    LINE = 3,
    ALL = 4,
  }

  /**
   * Text alignment / justification
   *
   * @default 0
   */
  type Justify =
    | Left
    | Right
    | Center
    | WithLastLineLeft
    | WithLastLineRight
    | WithLastLineCenter
    | WithLastLineFull;

  type Left = 0;
  type Right = 1;
  type Center = 2;
  type WithLastLineLeft = 3;
  type WithLastLineRight = 4;
  type WithLastLineCenter = 5;
  type WithLastLineFull = 6;

  const enum JUSTIFY {
    LEFT = 0,
    RIGHT = 1,
    CENTER = 2,
    WITH_LAST_LINE_LEFT = 3,
    WITH_LAST_LINE_RIGHT = 4,
    WITH_LAST_LINE_CENTER = 5,
    WITH_LAST_LINE_FULL = 6,
  }

  type Shape = Square | RampUp | RampDown | Triangle | Round | Smooth;
  type Square = 1;
  type RampUp = 2;
  type RampDown = 3;
  type Triangle = 4;
  type Round = 5;
  type Smooth = 6;

  const enum SHAPE {
    SQUARE = 1,
    RAMP_UP = 2,
    RAMP_DOWN = 3,
    TRIANGLE = 4,
    ROUND = 5,
    SMOOTH = 6,
  }

  type FontPathOrigin = Local | CssUrl | ScriptUrl | FontUrl;
  type Local = 0;
  type CssUrl = 1;
  type ScriptUrl = 2;
  type FontUrl = 3;

  const enum FONT_PATH_ORIGIN {
    LOCAL = 0,
    CSS_URL = 1,
    SCRIPT_URL = 2,
    FONT_URL = 3,
  }

  type VerticalJustify =
    | VerticalJustifyTop
    | VerticalJustifyCenter
    | VerticalJustifyBottom;

  type VerticalJustifyTop = 0;
  type VerticalJustifyCenter = 1;
  type VerticalJustifyBottom = 2;

  const enum VERTICAL_JUSTIFY {
    TOP = 0,
    CENTER = 1,
    BOTTOM = 2,
  }

  type RangeSelectorMode = Add | Subtract | Intersect | Min | Max | Difference;

  type Add = 0;
  type Subtract = 1;
  type Intersect = 2;
  type Min = 3;
  type Max = 4;
  type Difference = 5;

  enum RANGE_SELECTOR_MODE {
    ADD = 0,
    SUBTRACT = 1,
    INTERSECT = 2,
    MIN = 3,
    MAX = 4,
    DIFFERENCE = 5,
  }
}

declare namespace TrimMultipleShapes {
  /**
   * How to handle multiple shapes in trim path
   */
  type Value = Individually | Simultaneously;

  type Individually = 1;
  type Simultaneously = 2;

  const enum VALUES {
    INDIVIDUALLY = 1,
    SIMULTANEOUSLY = 2,
  }
}

declare namespace LayerStyleType {
  type Stroke = 0;
  type DropShadow = 1;
  type InnerShadow = 2;
  type OuterGlow = 3;
  type InnerGlow = 4;
  type BevelEmboss = 5;
  type Satin = 6;
  type ColorOverlay = 7;
  type GradientOverlay = 8;

  type Value =
    | Stroke
    | DropShadow
    | InnerShadow
    | OuterGlow
    | InnerGlow
    | BevelEmboss
    | Satin
    | ColorOverlay
    | GradientOverlay;
}

declare namespace Helpers {
  /**
   * Index used in expressions
   */
  type PropertyIndex = {
    ix?: number;
  };

  /**
   * Name, as seen from editors and the like
   * @note mainly for labeling
   */
  type Name = {
    nm?: string;
  };

  /**
   * Match name, used in expressions. Mainly for scripting
   * and packaging. Unique identifier
   */
  type MatchName = {
    mn?: string;
  };

  type Expression = {
    x?: string;
  };

  /**
   * @default 0
   */
  type Width = number;

  /**
   * @default 0
   */
  type Height = number;

  /**
   * @default ""
   */
  type ID = string;

  type Hidden = boolean;

  type Index = number;

  type CssClass = string;

  type InPoint = number;

  type OutPoint = number;

  /**
   * Framerate in frames per second
   * @default 60
   */
  type Framerate = {
    fr?: number;
  };

  /**
   * @default 0
   */
  type Time = number;

  type VisualObject = Name & MatchName;

  /**
   * Represents boolean values as an integer. 0 is false, 1 is true.
   * @default 0
   */
  type IntegerBoolean = 0 | 1;

  /**
   * Color as a [r, g, b] array with values in [0, 1]
   * @minimum 0
   * @maximum 1
   */
  type ColorRgba = [number, number, number] | [number, number, number, number];

  /**
   * Whether the animation has 3D layers. Lottie doesn't actually support 3D stuff so this should always be 0
   */
  type Threedimensional = {
    ddd?: IntegerBoolean;
  };

  /**
   * Number of components in the value arrays.\nIf present values will be truncated or expanded to match this length when accessed from expressions.
   * @type integer
   */
  type Length = {
    l?: number;
  };

  /**
   * Rotation in degrees, clockwise
   */
  type RotationClockwise = {
    r: AnimatedProperty.Value;
  };

  type RotationXYZ = {
    /**
     * X Rotation - Split rotation component
     */
    rx?: AnimatedProperty.Value;
    /**
     * Y Rotation - Split rotation component
     */
    ry?: AnimatedProperty.Value;
    /**
     * ZRotation - Split rotation component, equivalent to `r` when not split
     */
    rz?: AnimatedProperty.Value;
    /**
     * Orientation
     */
    or?: AnimatedProperty.MultiDimensional;
  };

  type TransformRotation = RotationClockwise | RotationXYZ;

  /**
   * Layer transform
   */
  type Transform = TransformRotation &
    VisualObject & {
      /**
       * Anchor point
       *
       * a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)
       */
      a?: AnimatedProperty.Position;
      /**
       * Scale factor, `[100, 100]` for no scaling
       */
      s?: AnimatedProperty.MultiDimensional;
      /**
       * Opacity
       */
      o?: AnimatedProperty.Value;
      /**
       * Skew
       *
       * Skew amount as an angle in degrees
       */
      sk?: AnimatedProperty.Value;
      /**
       * Skew Axis
       *
       * Direction along which skew is applied, in degrees (`0` skews along the X axis, `90` along the Y axis)
       */
      sa?: AnimatedProperty.Value;
      /**
       * Position - Translation or Translation with split components
       */
      p?: AnimatedProperty.Position | AnimatedProperty.SplitVector;
    };

  /**
   * Bezier shape used to mask/clip a layer
   */
  type Mask = Helpers.VisualObject & {
    /**
     * Inverted
     * @default false
     */
    inv?: boolean;
    /**
     * Mask Vertices
     */
    pt?: AnimatedProperty.Shape;
    /**
     * Opacity
     */
    o?: AnimatedProperty.Value;
    /**
     * Mode
     * @default 'i' (ModeIntersect)
     */
    mode?: MaskMode.Value;
    /**
     * Dilate
     */
    x?: AnimatedProperty.Value;
  };

  /**
   * Single bezier curve
   */
  interface Bezier {
    /**
     * Closed
     * @default False
     */
    c?: boolean;
    /**
     * In Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `in` tangents relative to the corresponding `v`.
     *
     * @default []
     */
    i: number[][];
    /**
     * Out Tangents
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the `out` tangents relative to the corresponding `v`.
     */
    o: number[][];
    /**
     * Vertices
     *
     * Array of points, each point is an array of coordinates.
     * These points are along the bezier path
     */
    v: number[][];
  }
}

declare namespace AnimatedProperty {
  /**
   * Bezier handle for keyframe interpolation
   *
   * Time component:\n0 means start time of the keyframe,\n1 means time of the next keyframe.
   */
  interface KeyframeBezierHandle {
    /**
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    x: Helpers.IntegerBoolean[] | Helpers.IntegerBoolean;
    /**
     * Value interpolation component:\n0 means start value of the keyframe,\n1 means value at the next keyframe.
     *
     * @if type array
     * @then minItems: 1
     * @default 0
     */
    y: Helpers.IntegerBoolean[] | Helpers.IntegerBoolean;
  }

  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe
   *
   * 'i' and 'o' are not included in the last element of the keyframe array usually when the
   * Bezier curve is not closed, or when the last vertex is defined by the last element is the
   * same as the first vertex.
   *
   * @if "h": { "const": 0 | undefined }
   * @then 'i' and 'o'
   */
  interface KeyframeBase {
    /**
     * Time
     * @default 0
     */
    t: Helpers.Time;
    /**
     * Hold
     * @default 0
     */
    h?: Helpers.IntegerBoolean;
    /**
     * In Tanget
     *
     * Easing tangent going into the next keyframe
     */
    i?: KeyframeBezierHandle;
    /**
     * Out Tanget
     *
     * Easing tangent leaving the current keyframe
     */
    o?: KeyframeBezierHandle;
  }

  /**
   * A Keyframes specifies the value at a specific time and the interpolation function to reach the next keyframe.
   */
  interface Keyframe extends KeyframeBase {
    /**
     * Value
     *
     * Value at this keyframe. Note the if the property is a scalar,
     * keyframe values are still represented as arrays.
     *
     * In a normal Bezier curve description, the start point of a segment
     * is defined by vertex 's' of any given Nth element of the array.
     * The control point is defined by the 'o' of the Nth element.
     * The curve segment's endpoint is the 's' of the (N+1)th element of the keyframe array,
     * and the second control point is the 'o' of the (N+1)th element.
     *
     * Generally, Bezier curves are defined with 's', 't', 'i', and 'o', with the
     * last element of the keyframes array normally having only 's' and 't'. In this format,
     * any segment of a Bezier curve is defined by any element as the starting point of the
     * segment and the following point as the endpoint. 's' is an option in the last element
     * in the keyframe array for keyframe descriptions that use both 's' and 'e', where 'e' is
     * the end-point of the Bezier curve.
     */
    s?: number[] | Helpers.Bezier[];
    /**
     * Bezier End Point (value)
     *
     * Value at the end of the keyframe, note that this is deprecated and you should use `s` from the next keyframe to get this value
     *
     * @deprecated true
     */
    e?: number[];
  }

  /**
   * Keyframe holding Bezier objects
   */
  interface ShapeKeyframe extends KeyframeBase {
    /**
     * Start
     */
    s: Helpers.Bezier[];
  }

  interface Main
    extends Helpers.PropertyIndex,
      Helpers.VisualObject,
      Helpers.Expression {
    /**
     * Animated - Whether the property is animated
     * @default 0
     */
    a?: Helpers.IntegerBoolean;
    /**
     * 'k' is the list of keyframes that define the change and the rate of change of
     * an animated property between any given two frames. therefore, 'k' is require for
     * all animated properties.
     */
    k:
      | Keyframe[]
      | Helpers.ColorRgba
      | ShapeKeyframe[]
      | Helpers.Bezier
      | number[]
      | number;
  }

  /**
   * An animatable property that holds an array of numbers
   */
  interface MultiDimensional extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value
     */
    k: Keyframe[] | number[];
  }

  /**
   * An animatable property that holds a Color
   */
  interface Color extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated value - Keyframe[];
     * @else Static Value - Color
     */
    k: Keyframe[] | Helpers.ColorRgba;
  }

  /**
   * Represents colors and offsets in a gradient
   *
   * Colors are represented as a flat list interleaving offsets and color components in weird ways
   * There are two possible layouts:
   *
   * Without alpha, the colors are a sequence of offset, r, g, b
   *
   * With alpha, same as above but at the end of the list there is a sequence of offset, alpha.
   *
   */
  interface GradientColors {
    /**
     * Colors
     */
    k: MultiDimensional;
    /**
     * Count
     * Number of colors in `k`
     * @default 0
     */
    p: number;
  }

  interface PositionKeyframe extends Keyframe {
    /**
     * Value In Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    ti?: number[];
    /**
     * Value Out Tangent
     * Tangent for values (eg: moving position around a curved path
     */
    to?: number[];
  }

  /**
   * An animatable property to represent a position in space
   */
  interface Position extends Main, Helpers.Length {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - PositionKeyframe[]
     * @else Static Value - number[]
     */
    k: PositionKeyframe[] | number[];
  }

  /**
   * An animatable property that holds a Bezier
   */
  interface Shape extends Main {
    /**
     * @if "h": { "const": 1  }
     * @then Animated Value - ShapeKeyframe[]
     * @else Static Value - Bezier
     */
    k: ShapeKeyframe[] | Helpers.Bezier;
  }

  /**
   * An animatable property that holds a float
   */
  interface Value extends Main {
    /**
     * @if "a": { "const": 1  }
     * @then Animated Value - Keyframe[]
     * @else Static Value - number
     */
    k: Keyframe[] | number;
  }

  /**
   *  An animatable property that is split into individually anaimated components
   */
  interface SplitVector {
    /**
     * Split
     */
    s: true;
    x: Value;
    y: Value;
    z?: Value;
  }
}

declare namespace Shape {
  type Opacity = AnimatedProperty.Value;

  /**
   * Base class for all elements of ShapeLayer and Group
   */
  interface Element extends Helpers.VisualObject, Helpers.PropertyIndex {
    /**
     * Whether the shape is hidden
     */
    hd?: Helpers.Hidden;
    ty: ShapeType.Value;
    bm?: BlendMode.Value;
    /**
     * Property Index
     *
     * Index used in expressions
     */
    cix?: Helpers.Index;
    /**
     * CSS Class
     *
     * CSS class used by the SVG renderer.
     */
    cl?: Helpers.CssClass;
    /**
     * Shape XML ID
     *
     * ID attribute used by the SVG renderer.
     */
    ln?: Helpers.ID;
  }

  /**
   * Drawable shape
   */
  interface Main extends Element {
    /**
     * Direction
     *
     * Direction the shape is drawn as, mostly relevant when using trim path
     */
    d?: ShapeDirection.Value;
  }

  interface Ellipse extends Main {
    ty: ShapeType.Ellipse;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
  }

  /**
   * Solid fill color
   */
  interface Fill extends Element {
    ty: ShapeType.Fill;
    o: Opacity;
    /**
     * Color
     */
    c: AnimatedProperty.Color;
    /**
     * Fill Rule
     */
    r?: FillRule.Value;
  }

  interface Gradient extends Element {
    /**
     * StartPoint
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * EndPoint
     */
    e: AnimatedProperty.MultiDimensional;
    t?: GradientType.Value;
    /**
     * Highlight Length
     */
    h?: AnimatedProperty.Value;
    /**
     * Highlight Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Colors
     */
    g: AnimatedProperty.GradientColors;
  }

  interface GradientFill extends Gradient {
    ty: ShapeType.GradientFill;
    o: Opacity;
    r?: FillRule.Value;
  }

  /**
   * An item used to described the dashe pattern in a stroked path
   */
  interface StrokeDash extends Helpers.VisualObject {
    /**
     * @default 2
     */
    n?: StrokeDashType.Value;
    /**
     * Length
     */
    v?: AnimatedProperty.Value;
  }

  interface BaseStroke {
    /**
     * @default 2
     */
    lc?: LineCap.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     * @default 0
     */
    ml?: number;
    /**
     * Animatable alternative to ml
     */
    ml2?: AnimatedProperty.Value;
    o: Opacity;
    /**
     * Width
     */
    w: AnimatedProperty.Value;
    /**
     * Dashes
     */
    d?: StrokeDash[];
  }

  interface GradientStroke extends Gradient, BaseStroke {
    ty: ShapeType.GradientStroke;
  }

  /**
   * Shape Element that can contain other shapes
   */
  interface Group extends Element {
    ty: ShapeType.Group;
    /**
     * NumberOfProperties
     */
    np?: number;
    it?: Value[];
    /**
     * Property Index
     *
     * Index used in expressions
     * @type integer
     */
    cix?: number;
  }

  /**
   * Animatable Bezier curve
   */
  interface Path extends Main {
    ty: ShapeType.Path;
    /**
     * Shape
     */
    ks: AnimatedProperty.Shape;
    ind?: Helpers.Index;
  }

  interface IPolyStar extends Main {
    ty: ShapeType.PolygonStar;
    /**
     * Position
     */
    p: AnimatedProperty.Position;
    /**
     * Outer Radius
     */
    or: AnimatedProperty.Value;
    /**
     * Outer Roundness
     *
     * Outer Roundness as a percentage
     */
    os: AnimatedProperty.Value;
    /**
     * Rotation, clockwise in degrees
     */
    r: AnimatedProperty.Value;
    /**
     * Points
     */
    pt: AnimatedProperty.Value;
    /**
     * @default 1
     */
    sy?: PolyStarType.Value;
  }

  interface Polygon extends IPolyStar {
    sy: PolyStarType.Polygon;
  }

  interface Star extends IPolyStar {
    sy: PolyStarType.Star;
    /**
     * Inner Radius
     */
    ir: AnimatedProperty.Value;
    /**
     * Inner Roundness
     *
     * Inner Roundness as a percentage
     */
    is: AnimatedProperty.Value;
  }

  /**
   * Star or regular polygon
   * @if { "sy": 1 }
   * @then Star
   * @else Polygon
   */
  type PolyStar = Star | Polygon;

  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface PuckerBloat extends Element {
    ty: ShapeType.PuckerBloat;
    /**
     * Amount
     *
     * Amount as a percentage
     */
    a?: AnimatedProperty.Value;
  }

  /**
   * A simple rectangle shape
   */
  interface Rectangle extends Main {
    ty: ShapeType.Rectangle;
    /**
     * Position
     *
     * Center of the rectangle
     */
    p: AnimatedProperty.Position;
    /**
     * Size
     */
    s: AnimatedProperty.MultiDimensional;
    /**
     * Rounded
     */
    r: AnimatedProperty.Value;
  }

  interface Modifier extends Element {}

  /**
   * Transform used by a repeater, the transform is applied to each subsequent repeated object.
   */
  type RepeaterTransform = Helpers.Transform & {
    /**
     * Start Opacity
     *
     * Opacity of the first repeated object.
     */
    so?: Opacity;
    /**
     * End Opacity
     *
     * Opacity of the last repeated object.
     */
    eo?: Opacity;
  };

  /**
   * Duplicates previous shapes in a group
   */
  interface Repeater extends Modifier {
    ty: ShapeType.Repeater;
    /**
     * Copies
     */
    c: AnimatedProperty.Value;
    /**
     * Offset
     */
    o?: AnimatedProperty.Value;
    /**
     * @default 1
     */
    m?: Composite.Value;
    /**
     * Transform
     */
    tr: RepeaterTransform;
  }

  /**
   * Rounds corners of other shapes
   */
  interface RoundedCorners extends Modifier {
    ty: ShapeType.RoundedCorners;
    /**
     * Radius
     */
    r: AnimatedProperty.Value;
  }

  /**
   * Solid stroke
   */
  interface Stroke extends Element, BaseStroke {
    ty: ShapeType.Stroke;
    /**
     * Color
     */
    c: AnimatedProperty.MultiDimensional;
  }

  /**
   * Group transform
   */
  type Transform = Element &
    Helpers.Transform & {
      ty: ShapeType.Transform;
    };

  /**
   * Trims shapes into a segment
   */
  interface Trim extends Modifier {
    ty: ShapeType.Trim;
    /**
     * Start
     */
    s: AnimatedProperty.Value;
    /**
     * End
     */
    e: AnimatedProperty.Value;
    /**
     * Offset
     */
    o: AnimatedProperty.Value;
    /**
     * Multiple
     */
    m?: TrimMultipleShapes.Value;
  }

  interface Twist extends Element {
    ty: ShapeType.Twist;
    /**
     * Angle
     */
    a?: AnimatedProperty.Value;
    /**
     * Center
     */
    c?: AnimatedProperty.MultiDimensional;
  }

  interface Merge extends Element {
    ty: ShapeType.Merge;
    /**
     * Merge Mode
     * @default 1
     */
    mm?: number;
  }

  /**
   * Interpolates the shape with its center point and bezier tangents with the opposite direction
   */
  interface OffsetPath extends Element {
    ty: ShapeType.OffsetPath;
    /**
     * Amount
     */
    a?: AnimatedProperty.Value;
    /**
     * @default 2
     */
    lj?: LineJoin.Value;
    /**
     * Miter Limit
     */
    ml?: AnimatedProperty.Value;
  }

  /**
   * Changes the edges of affected shapes into a series of peaks and valleys of uniform size
   */
  interface ZigZags extends Element {
    ty: ShapeType.ZigZag;
    /**
     * Roundness
     *
     * Radius to maked it a smoother curve
     */
    r?: AnimatedProperty.Value;
    /**
     * Size
     *
     * Distance between peaks and troughs
     */
    s?: AnimatedProperty.Value;
    /**
     * Points
     *
     * Number of ridges
     */
    pt?: AnimatedProperty.Value;
  }

  /**
   * List of valid shapes (prev. Shape List)
   */
  type Value =
    | Ellipse
    | Fill
    | GradientFill
    | GradientStroke
    | Group
    | Path
    | PolyStar
    | PuckerBloat
    | Rectangle
    | Repeater
    | RoundedCorners
    | Stroke
    | Transform
    | Trim
    | Twist
    | Merge
    | OffsetPath
    | ZigZags;
}

declare namespace Text {
  /**
   * @default ""
   */
  type FontFamily = string;
  type FontSize = number;
  type FontStyle = string;

  /**
   * Defines a character as shapes
   */
  interface CharacterShapes {
    /**
     * Shape forming the character
     */
    shapes: Shape.Value[];
  }

  /**
   * Defines a character as a precomp layer
   */
  interface CharacterPrecomp {
    /**
     * Reference Id
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Transform
     *
     * Layer transform
     */
    ks?: Helpers.Transform;
    /**
     * In Point
     *
     * Frame when the layer becomes visible
     *
     * @default 0
     */
    ip?: Helpers.InPoint;
    /**
     * Out Point
     *
     * Frame when the layer becomes invisible
     * @default 99999
     */
    op?: Helpers.OutPoint;
    /**
     * Time Stretch
     * @default 1
     */
    sr?: Helpers.Time;
    /**
     * Start Time
     *
     * @default 0
     */
    st?: Helpers.Time;
  }

  /**
   * Defines character shapes
   */
  interface CharacterData extends Data {
    data: CharacterShapes | CharacterPrecomp;
    /**
     * Character
     * @default ""
     */
    ch: string;
    fFamily: FontFamily;
    /**
     * @default 0
     */
    size: FontSize;
    /**
     * @default ""
     */
    style: FontStyle;
    w: Helpers.Width;
  }

  /*
   * Describes how a font with given settings should be loaded
   */
  interface Font {
    /**
     * Ascent
     *
     * Text will be moved down based on this value
     */
    ascent?: number;
    /**
     * Font Family
     *
     * @default "sans"
     */
    fFamily: FontFamily;
    /**
     * Font Name
     *
     * Name used by text documents to reference this font, usually it's `fFamily` followed by `fStyle`
     * @default "sans-regular"
     */
    fName: string;
    /**
     * Font Style
     *
     * @default "Regular"
     * @example ["Regular", "Bold", "Bold Italic"]
     */
    fStyle: FontStyle;
    /**
     * Font Path
     */
    fPath?: string;
    /**
     * Font Weight
     */
    fWeight?: string;
    /**
     * Origin
     */
    origin: TextType.FontPathOrigin;
    /**
     * Font CSS Class
     *
     * A class applied to text objects using this font
     */
    fClass?: Helpers.CssClass;
  }

  interface FontList {
    list: Font[];
  }

  /**
   * Uses the path described by a layer mask to put the text on said path.
   */
  interface MaskedPath {
    /**
     * Mask
     *
     * Index of the mask to use
     *
     * @type integer
     */
    m?: number;
    /**
     * First Margin
     */
    f?: AnimatedProperty.Value;
    /**
     * Last Margin
     */
    l?: AnimatedProperty.Value;
    /**
     * Reverse Path
     */
    r?: AnimatedProperty.Value;
    /**
     * Force Alignment
     */
    a?: AnimatedProperty.Value;
    /**
     * Perpendicular To Path
     */
    p?: AnimatedProperty.Value;
  }

  /**
   * Text Animator Data Property
   */
  type AnimatorDataProperty = Helpers.Transform & {
    /**
     * Stroke Width
     */
    sw?: AnimatedProperty.Value;
    /**
     * Stroke Color
     */
    sc?: AnimatedProperty.Color;
    /**
     * Stroke Hue
     */
    sh?: AnimatedProperty.Value;
    /**
     * Stroke Saturation
     */
    ss?: AnimatedProperty.Value;
    /**
     * Stroke Brightness
     */
    sb?: AnimatedProperty.Value;
    /**
     * Stroke Opacity
     */
    so?: AnimatedProperty.Value;
    /**
     * Fill Color
     */
    fc?: AnimatedProperty.Color;
    /**
     * Fill Hue
     */
    fh?: AnimatedProperty.Value;
    /**
     * Fill Saturation
     */
    fs?: AnimatedProperty.Value;
    /**
     * Fill Opacity
     */
    fo?: AnimatedProperty.Value;
    /**
     * Fill Brightness
     */
    fb?: AnimatedProperty.Value;
    /**
     * Tracking
     */
    t?: AnimatedProperty.Value;
    /**
     * Blur
     */
    bl?: AnimatedProperty.Value;
    /**
     * Line Spacing
     */
    ls?: AnimatedProperty.Value;
  };

  interface SelectorProperty {
    /**
     * Expressible
     */
    t: Helpers.IntegerBoolean;
    /**
     * Max Ease
     */
    xe: AnimatedProperty.Value;
    /**
     * Min Ease
     */
    ne: AnimatedProperty.Value;
    /**
     * Max Amount
     */
    a: AnimatedProperty.Value;
    /**
     * Based On
     */
    b: TextType.Based;
    /**
     * Randomize
     */
    rn: Helpers.IntegerBoolean;
    /**
     * Shape
     */
    sh: TextType.Shape;
    /**
     * Offset
     */
    o: AnimatedProperty.Value;
    /**
     * Range Units
     *
     * @type integer
     */
    r?: number;
    /**
     * Selector Smoothness
     */
    sm?: AnimatedProperty.Value;
    /**
     * Start
     */
    s?: AnimatedProperty.Value;
    /**
     * End
     */
    e?: AnimatedProperty.Value;
    /**
     * Mode
     */
    m?: TextType.RangeSelectorMode;
  }

  interface Selector extends Helpers.Name {
    /**
     * Transform
     */
    a?: {
      s: AnimatedProperty.Position;
    };
    s?: SelectorProperty;
  }

  /**
   * Text More Options
   */
  interface MoreOptions {
    /**
     * Alignment
     *
     * Group alignment
     */
    a?: AnimatedProperty.MultiDimensional;
    /**
     * Anchor point grouping
     */
    g?: TextType.Grouping;
  }

  /**
   * Text Document
   *
   * Note that for multi-line text, lines are separated by \\r
   */
  interface Document {
    /**
     * Font Family
     * @default ""
     */
    f: FontFamily;
    /**
     * Fill Color
     * @default [0,0,0]
     */
    fc: Helpers.ColorRgba;
    /**
     * Stroke Color
     */
    sc?: Helpers.ColorRgba;

    /**
     * Stroke Width
     * @default 0
     */
    sw?: number;
    /**
     * Stroke Over Fill
     * Render stroke above the fill
     */
    of?: boolean;
    /**
     * @default 10
     */
    s: FontSize;
    /**
     * LineHeight
     * Line height when wrapping
     */
    lh?: number;
    /**
     * Wrap Size
     *
     * Size of the box containing the text
     */
    sz?: [number, number];
    /**
     * Wrap Position
     *
     * Position of the box containing the text
     */
    ps?: [number, number];
    /**
     * note that newlines are encoded with \\r
     *
     * @default ''
     */
    t: string;
    /**
     * @default 0
     */
    j?: TextType.Justify;
    ca?: TextType.Caps;
    /**
     * Text Tracking
     */
    tr?: number;
    /**
     * Baseline Shify
     */
    ls?: number;
    /**
     * Vertical justification. (Skottie)
     */
    vj?: TextType.VerticalJustify;
  }

  interface DataKeyframe {
    /**
     * Start
     */
    s: Document;
    /** Start time of keyframe segment. */
    t: Helpers.Time;
  }

  /**
   * Text Data
   *
   * Animated property representing the text contents
   */
  interface Data extends Helpers.Expression {
    k: DataKeyframe[];
  }

  type AnimatorDataProperties = AnimatorDataProperty | Selector;

  interface AnimatorData {
    a: AnimatorDataProperties[];
    d: Data;
    m: MoreOptions;
    p: MaskedPath;
  }
}

declare namespace EffectValue {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    ty?: EffectValueType.Value;
    v?:
      | AnimatedProperty.Value
      | AnimatedProperty.Color
      | AnimatedProperty.MultiDimensional
      | number;
  }

  interface NoValue extends Main {}

  interface Angle extends Main {
    ty: EffectValueType.Angle;
    v?: AnimatedProperty.Value;
  }

  interface Checkbox extends Main {
    ty: EffectValueType.Checkbox;
    v?: AnimatedProperty.Value;
  }

  interface Color extends Main {
    ty: EffectValueType.Color;
    v?: AnimatedProperty.Color;
  }

  interface DropDown extends Main {
    ty: EffectValueType.Dropdown;
    v?: AnimatedProperty.Value;
  }

  interface IgnoredValue extends Main {
    ty: EffectValueType.Ignored;
    v?: number;
  }

  interface Layer extends Main {
    ty: EffectValueType.Layer;
    v?: AnimatedProperty.Value;
  }

  interface Point extends Main {
    ty: EffectValueType.Point;
    v?: AnimatedProperty.MultiDimensional;
  }

  interface Slider extends Main {
    ty: EffectValueType.Slider;
    v?: AnimatedProperty.Value;
  }

  type Value =
    | NoValue
    | Angle
    | Checkbox
    | Color
    | DropDown
    | IgnoredValue
    | Layer
    | Point
    | Slider;
}

declare namespace Effect {
  interface Main extends Helpers.VisualObject, Helpers.PropertyIndex {
    /** Effect Parameters */
    ef: EffectValue.Value[];
    ty: EffectType.Value;
    /** Enabled */
    en?: Helpers.IntegerBoolean;
  }

  /**
   * Adds a shadow to the layer
   */
  interface DisplacementMap extends Main {
    ty: EffectType.DisplacementMap;
    ef: [
      /** Displacement Map Layer */
      EffectValue.Layer,
      /** Use For Horizontal Displacement */
      EffectValue.DropDown,
      /** Max Horizontal Displacement */
      EffectValue.Slider,
      /** Use For Vertical Displacement */
      EffectValue.DropDown,
      /** Max Vertical Displacement */
      EffectValue.Slider,
      /** Displacement Map Behavior */
      EffectValue.DropDown,
      /** Edge Behavior */
      EffectValue.DropDown,
      /** Expand Output */
      EffectValue.DropDown
    ];
  }

  interface DropShadow extends Main {
    ty: EffectType.DropShadow;
    ef: [
      /** Color */
      EffectValue.Color,
      /** Opacity between 0 and 255 */
      EffectValue.Slider,
      /** Angle */
      EffectValue.Angle,
      /** Distance */
      EffectValue.Slider,
      /** Blur */
      EffectValue.Slider
    ];
  }

  /**
   * Replaces the whole layer with the given color
   *
   * Opacity is in [0, 1]
   */
  interface Fill extends Main {
    ty: EffectType.Fill;
    ef: [
      /** 00 */
      EffectValue.Point,
      /** 01 */
      EffectValue.DropDown,
      /** Color */
      EffectValue.Color,
      /** Color */
      EffectValue.Color,
      /** 03 */
      EffectValue.DropDown,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** Opacity in [0, 1] */
      EffectValue.Slider
    ];
  }

  /**
   * Gaussian blur
   */
  interface GaussianBlur extends Main {
    ty: EffectType.GaussianBlur;
    ef: [
      /** Sigma */
      EffectValue.Slider,
      /** Dimensions */
      EffectValue.Slider,
      /** Wrap */
      EffectValue.Checkbox
    ];
  }

  interface Matte3 extends Main {
    ty: EffectType.Matte3;
    ef: [
      /** Index */
      EffectValue.Slider
    ];
  }

  interface MeshWarp extends Main {
    ty: EffectType.MeshWarp;
    ef: [
      /** Rows */
      EffectValue.Slider,
      /** Columns */
      EffectValue.Slider,
      /** Quality */
      EffectValue.Slider,
      /** 03 */
      EffectValue.NoValue
    ];
  }

  interface PaintOverTransparent extends Main {
    ty: EffectType.PaintOverTransparent;
    ef: [
      /** 00 */
      EffectValue.Slider
    ];
  }

  interface ProLevels extends Main {
    ty: EffectType.ProLevels;
    ef: [
      /** 00 */
      EffectValue.DropDown,
      /** 01 */
      EffectValue.NoValue,
      /** 02 */
      EffectValue.NoValue,
      /** comp_inblack */
      EffectValue.Slider,
      /** comp_inwhite */
      EffectValue.Slider,
      /** comp_gamma */
      EffectValue.Slider,
      /** comp_outblack */
      EffectValue.NoValue,
      /** comp_outwhite */
      EffectValue.NoValue,
      /** 08 */
      EffectValue.NoValue,
      /** 09 */
      EffectValue.Slider,
      /** r_inblack */
      EffectValue.Slider,
      /** r_inwhite */
      EffectValue.Slider,
      /** r_gamma */
      EffectValue.Slider,
      /** r_outblack */
      EffectValue.Slider,
      /** r_outwhite */
      EffectValue.Slider,
      /** 15 */
      EffectValue.Slider,
      /** 16 */
      EffectValue.Slider,
      /** g_inblack */
      EffectValue.Slider,
      /** g_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** g_outblack */
      EffectValue.Slider,
      /** g_outwhite */
      EffectValue.Slider,
      /** 22 */
      EffectValue.Slider,
      /** 23 */
      EffectValue.Slider,
      /** b_inblack */
      EffectValue.Slider,
      /** b_inwhite */
      EffectValue.Slider,
      /** b_gamma */
      EffectValue.Slider,
      /** b_outblack */
      EffectValue.Slider,
      /** b_outwhite */
      EffectValue.Slider,
      /** 29 */
      EffectValue.Slider,
      /** a_inblack */
      EffectValue.Slider,
      /** a_inwhite */
      EffectValue.Slider,
      /** g_gamma */
      EffectValue.Slider,
      /** a_outblack */
      EffectValue.Slider,
      /** a_outwhite */
      EffectValue.Slider
    ];
  }

  interface Puppet extends Main {
    ty: EffectType.Puppet;
    ef: [
      /** Puppet Engine */
      EffectValue.DropDown,
      /** Mesh Rotation Refinement */
      EffectValue.Slider,
      /** On Transparent */
      EffectValue.DropDown,
      /** 03 */
      EffectValue.NoValue
    ];
  }

  interface RadialWipe extends Main {
    ty: EffectType.RadialWipe;
    ef: [
      /** Completion. Between 0 and 100 */
      EffectValue.Slider,
      /** Start Angle */
      EffectValue.Angle,
      /** Wipe Center */
      EffectValue.Point,
      /** Wipe */
      EffectValue.Slider,
      /** Feather */
      EffectValue.Slider
    ];
  }

  interface Spherize extends Main {
    ty: EffectType.Spherize;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point
    ];
  }

  interface Stroke extends Main {
    ty: EffectType.Stroke;
    ef: [
      /** 00 */
      EffectValue.Color,
      /** 01 */
      EffectValue.Checkbox,
      /** 02 */
      EffectValue.Checkbox,
      /** Color */
      EffectValue.Color,
      /** 04 */
      EffectValue.Slider,
      /** 05 */
      EffectValue.Slider,
      /** 06 */
      EffectValue.Slider,
      /** 07 */
      EffectValue.Slider,
      /** 08 */
      EffectValue.Slider,
      /** 09 */
      EffectValue.DropDown,
      /** type */
      EffectValue.DropDown
    ];
  }

  /**
   * Colorizes the layer
   *
   * Opacity in [0, 100]
   */
  interface Tint extends Main {
    ty: EffectType.Tint;
    ef: [
      /**
       * Black Color.
       *
       * Tint of the darker parts of the layer.
       */
      EffectValue.Color,
      /**
       * White Color
       *
       * Tint of the lighter parts of the layer
       */
      EffectValue.Color,
      /**
       * Intensity
       *
       * Intensity of the effect, 0 means the layer is unchanged. 100 means full effect.
       */
      EffectValue.Slider
    ];
  }

  /**
   * Maps layers colors based on bright/mid/dark colors
   */
  interface Tritone extends Main {
    ty: EffectType.Tritone;
    ef: [
      /** Bright */
      EffectValue.Color,
      /** Mid */
      EffectValue.Color,
      /** Dark */
      EffectValue.Color
    ];
  }

  interface Wavy extends Main {
    ty: EffectType.Wavy;
    ef: [
      /** Radius */
      EffectValue.Slider,
      /** Center */
      EffectValue.Point,
      /** Conversion Type */
      EffectValue.DropDown,
      /** Speed */
      EffectValue.DropDown,
      /** Width */
      EffectValue.Slider,
      /** Height */
      EffectValue.Slider,
      /** Phase */
      EffectValue.Slider
    ];
  }

  /**
   * Some lottie files use `ty` = 5 for many different effects
   */
  interface Custom extends Main {
    ty: EffectType.Custom;
  }

  /**
   * Layer Effect
   */
  type Value =
    | Custom
    | DropShadow
    | Fill
    | GaussianBlur
    | Matte3
    | ProLevels
    | Stroke
    | Tint
    | Tritone
    | RadialWipe
    | Wavy
    | Puppet
    | Spherize
    | PaintOverTransparent
    | MeshWarp
    | DisplacementMap;
}

declare namespace Style {
  type OpacityValue = AnimatedProperty.Value;

  type ColorValue = AnimatedProperty.Color;

  type AngleValue = AnimatedProperty.Value;

  interface ChokeSpread {
    ch?: AnimatedProperty.Value;
  }

  interface BlendMode {
    bm?: AnimatedProperty.Value;
  }

  interface Opacity {
    o?: OpacityValue;
  }

  /**
   * Size or Blur Size
   */
  interface Size {
    s?: AnimatedProperty.Value;
  }

  interface Noise {
    no?: AnimatedProperty.Value;
  }

  interface Distance {
    d?: AnimatedProperty.Value;
  }

  interface Color {
    c?: ColorValue;
  }

  /**
   * Local light angle
   */
  interface Angle {
    a?: AngleValue;
  }
  /**
   * Layer Style
   *
   * Style applied to a layer
   */
  interface Layer extends Helpers.VisualObject {
    /**
     * Type
     *
     * Style Type
     * @type integer
     */
    ty: LayerStyleType.Value;
  }

  interface Stroke extends Layer, Size, Color {
    ty: LayerStyleType.Stroke;
  }

  interface DropShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.DropShadow;
    /**
     * Layer Conceal
     *
     * Layer knowck out drop shadow
     */
    lc?: AnimatedProperty.Value;
  }

  interface InnerShadow
    extends Layer,
      Color,
      Opacity,
      Angle,
      Size,
      Distance,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.InnerShadow;
  }

  interface OuterGlow
    extends Layer,
      Color,
      Opacity,
      ChokeSpread,
      BlendMode,
      Noise {
    ty: LayerStyleType.OuterGlow;
    /**
     * Range
     */
    r?: AnimatedProperty.Value;
    /**
     * Jitter
     */
    j?: AnimatedProperty.Value;
  }

  interface InnerGlow extends Omit<OuterGlow, "ty"> {
    ty: LayerStyleType.InnerGlow;
    /**
     * Source
     */
    sr?: AnimatedProperty.Value;
  }

  interface BevelEmboss extends Layer, Size, Angle {
    ty: LayerStyleType.BevelEmboss;
    /**
     * Bevel Style
     */
    bs?: AnimatedProperty.Value;
    /**
     * Technique
     */
    bt?: AnimatedProperty.Value;
    /**
     * Strength
     */
    sr?: AnimatedProperty.Value;
    /**
     * Soften
     */
    sf?: AnimatedProperty.Value;
    /**
     * Global Angle
     *
     * Use global light
     */
    ga?: AngleValue;
    /**
     * Altitude
     *
     * Local lighting altitude
     */
    ll?: AnimatedProperty.Value;
    /**
     * Highlight Mode
     */
    hm?: AnimatedProperty.Value;
    /**
     * Highlight Color
     */
    hc?: ColorValue;
    /**
     * Highlight Opacity
     */
    ho?: OpacityValue;
    /**
     * Shadow Mode
     */
    sm?: AnimatedProperty.Value;
    /**
     * Shadow Color
     */
    sc?: ColorValue;
    /**
     * Shadow Opacity
     */
    so?: OpacityValue;
  }

  interface Satin
    extends Layer,
      BlendMode,
      Color,
      Opacity,
      Angle,
      Distance,
      Size {
    ty: LayerStyleType.Satin;
    /**
     * Invert
     */
    in?: AnimatedProperty.Value;
  }

  interface ColorOverlay extends Layer, BlendMode, Color {
    ty: LayerStyleType.ColorOverlay;
    /**
     * Opacity
     */
    so?: OpacityValue;
  }

  interface GradientOverlay extends Layer, BlendMode, Opacity, Angle {
    ty: LayerStyleType.GradientOverlay;
    /**
     * Gradient
     */
    gf?: AnimatedProperty.GradientColors;
    /**
     * Smoothness
     */
    gs?: AnimatedProperty.Value;
    /**
     * Gradient Type
     */
    gt?: GradientType.Value;
    /**
     * Reverse
     */
    re?: AnimatedProperty.Value;
    /**
     * Align
     *
     * Align with layer
     */
    al?: AnimatedProperty.Value;
    /**
     * Scale
     */
    s?: AnimatedProperty.Value;
    /**
     * Offset
     */
    of?: AnimatedProperty.Value;
  }

  type Value =
    | Stroke
    | DropShadow
    | InnerShadow
    | OuterGlow
    | InnerGlow
    | BevelEmboss
    | Satin
    | ColorOverlay
    | GradientOverlay;
}

declare namespace Layer {
  interface Main extends Helpers.VisualObject, Helpers.Threedimensional {
    /**
     * Whether the layer is hidden
     */
    hd?: Helpers.Hidden;
    ty: LayerType.Value;
    /**
     * Index that can be used for parenting and referenced in expressions
     * @type integer
     */
    ind?: Helpers.Index;
    /**
     * Parent Index
     *
     * Must be the `ind` property of another Layer
     */
    parent?: number;
    /**
     * Time Stretch
     */
    sr?: Helpers.Time;
    /**
     * In Point - Frame when the layer becomes visible
     */
    ip: Helpers.InPoint;
    /**
     * Out Point - Frame when the layer becomes invisible
     */
    op: Helpers.OutPoint;
    /**
     * Start Time
     */
    st?: Helpers.Time;
    /**
     * Blend Mode
     * @default 0
     */
    bm?: BlendMode.Value;
    /**
     * CSS class used by the SVG renderer
     */
    cl?: Helpers.CssClass;
    /**
     * Layer XML ID
     *
     * ID attribute used by the SVG renderer
     */
    ln?: Helpers.ID;
    /**
     * Layer XML tag name
     *
     * tag name used by the SVG renderer
     */
    tg?: string;
  }

  interface AudioSettings {
    /**
     * Level
     */
    lv: AnimatedProperty.MultiDimensional;
  }

  /**
   * A layer playing sounds
   */
  interface Audio extends Main {
    ty: LayerType.Audio;
    au: AudioSettings;
    /**
     * Sound Id
     *
     * ID of the sound as specified in the assets.
     */
    refId?: Helpers.ID;
  }

  /**
   * Layer used to affect visual elements
   */
  interface Visual extends Main {
    /**
     * Collapse Transform
     */
    cp?: boolean;
    /**
     * Layer Transform
     */
    ks: Helpers.Transform;
    /**
     * AutoOrient
     *
     * If 1, The layer will rotate itself to match its animated position path
     * @default 0
     */
    ao?: Helpers.IntegerBoolean;
    /** Matte mode, the layer will inherit the transparency from the layer above */
    tt?: MatteMode.Value;
    /**
     * Matte Target
     */
    td?: number;
    /**
     * Whether the layer has masks applied
     */
    hasMask?: boolean;
    /** List of Masks */
    masksProperties?: Helpers.Mask[];
    /**
     * List of Effects
     */
    ef?: Effect.Value[];
    /**
     * Motion Blur
     *
     * Whether motion blur is enabled for the layer
     */
    mb?: boolean;
    /**
     * Layer Style
     *
     * Styling effects for this layer
     */
    sy?: Style.Value[];
  }

  /**
   * Layer that renders a Precomposition asset
   */
  interface Precomposition extends Visual {
    ty: LayerType.Precomposition;
    /**
     * Reference ID
     *
     * ID of the precomp as specified in the assets
     */
    refId: Helpers.ID;
    /**
     * Width of the clipping rect
     */
    w: Helpers.Width;
    /**
     * Height of the clipping rect
     */
    h: Helpers.Height;
    /**
     * Time Remapping
     */
    tm?: AnimatedProperty.Value;
  }

  /**
   * Layer containing Shapes
   */
  interface Shape extends Visual {
    ty: LayerType.Shape;
    shapes: Shape.Value[];
  }

  /**
   * Layer with a solid color rectangle
   */
  interface SolidColor extends Visual {
    ty: LayerType.SolidColor;
    /**
     * Color
     *
     * Color of the layer, unlike most other places, the color is a `#rrggbb` hex string
     */
    sc: string;
    /**
     * @default 512
     */
    sh: Helpers.Height;
    /**
     * @default 512
     */
    sw: Helpers.Width;
  }

  /**
   * Layer that shows an image asset
   */
  interface Image extends Visual {
    ty: LayerType.Image;
    /**
     * Image ID
     *
     * ID of the image as specified in the assets
     * @default ""
     */
    refId: Helpers.ID;
  }

  /**
   * Layer with no data, useful to group layers together
   */
  interface Null extends Visual {
    ty: LayerType.Null;
  }

  /**
   * Layer with some text
   */
  interface Text extends Visual {
    ty: LayerType.Text;
    /**
     * Data
     */
    t: Text.AnimatorData;
  }

  interface Camera extends Main {
    ty: LayerType.Camera;
    /**
     * Perspective
     *
     * Distance from the Z=0 plane.\nSmall values yield a higher perspective effect.
     */
    pe: AnimatedProperty.Value;
    ks: Helpers.Transform;
  }

  interface Data extends Main {
    ty: LayerType.Data;
    /**
     * Data source ID
     *
     * ID of the data source in assets
     */
    refId?: Helpers.ID;
  }

  interface VideoPlaceholder extends Main {
    ty: LayerType.VideoPlaceholder;
  }

  interface ImageSequence extends Main {
    ty: LayerType.ImageSequence;
  }

  interface Video extends Main {
    ty: LayerType.Video;
  }

  interface ImagePlaceholder extends Main {
    ty: LayerType.ImagePlaceholder;
  }

  interface Guide extends Main {
    ty: LayerType.Guide;
  }

  interface Adjustment extends Main {
    ty: LayerType.Adjustment;
  }

  interface Light extends Main {
    ty: LayerType.Light;
  }

  type Value =
    | Audio
    | Precomposition
    | SolidColor
    | Image
    | Null
    | Shape
    | Text
    | Camera
    | VideoPlaceholder
    | Data
    | ImageSequence
    | Video
    | ImagePlaceholder
    | Guide
    | Adjustment
    | Light;
}

/**
 * Defines named portions of the composition.
 */
type Marker = {
  /**
   * Comment
   */
  cm?: string;
  tm?: Helpers.Time;
  /**
   * Duration
   */
  dr?: number;
};

/**
 * Base class for layer holders
 */
interface Composition {
  layers: Layer.Value[];
}

/**
 * Document metadata
 */
interface Metadata {
  /**
   * Author
   */
  a?: string;
  /**
   * Keywords
   */
  k?: string | string[];
  /**
   * Description
   */
  d?: string;
  /**
   * ThemeColor
   */
  tc?: string;
  /**
   * Generator
   *
   * Software used to generate the file
   */
  g?: string;
}

/**
 * Motion blur settings
 */
interface MotionBlur {
  /**
   * Shutter Angle
   *
   * Angle in degrees
   * AE default: 180
   * Skottie default: O ([0, 720])
   */
  sa?: number;
  /**
   * Shutter Phase
   *
   * Angle in degrees
   * AE default: -90
   * Skottie default: 0 ([-360, 360])
   */
  sp?: number;
  /**
   * Samples Per Frame
   * AE default: 16
   * Skottie default: 1 ([1, 64])
   */
  spf?: number;
  /**
   * Adaptive Sample Limit
   *
   * (not yet supported in any known Lottie player)
   * AE default: 128
   * 2D layer motion automatically uses more samples per frame
   * when needed, up to the value specified by Adaptive Sample Limit.
   */
  asl?: number;
}

/**
 * Top level object, describing the animation
 */
interface Animation
  extends Helpers.VisualObject,
    Helpers.Threedimensional,
    Helpers.Framerate,
    Composition {
  /**
   * Version
   * @default 5.5.2
   */
  v?: string;
  /**
   * "In Point", which frame the animation starts at (usually 0)
   * @default 0
   */
  ip: Helpers.InPoint;
  /**
   * "Out Point", which frame the animation stops/loops at, which makes this the duration in frames when `ip` is 0
   * @default 60
   */
  op: Helpers.OutPoint;
  /**
   * Width of the animation
   * @default 512
   */
  w: Helpers.Width;
  /**
   * Height of the animation
   * @default 512
   */
  h: Helpers.Height;
  /**
   * List of assets that can be referenced by layers
   */
  assets?: Asset.Value[];
  /**
   * Extra Compositions
   *
   * List of Extra compositions not referenced by anything
   */
  comps?: Asset.Precomposition[];
  fonts?: Text.FontList;
  /**
   * Data defining text characters as lottie shapes. If present a player
   * might only render characters defined here and nothing else.
   */
  chars?: Text.CharacterData[];
  meta?: Metadata;
  /**
   * User Metadata
   *
   * User-defined metadata
   */
  metadata?: object;
  /**
   * Markers defining named sections of the composition.
   */
  markers?: Marker[];
  mb?: MotionBlur;
}

declare namespace Asset {
  interface Main extends Helpers.Name {
    /**
     * ID
     *
     * Unique identifier used by layers when referencing this asset
     * @default ""
     */
    id: string;
  }

  /**
   * Asset referencing a file
   */
  interface File extends Main {
    /**
     * Path
     *
     * Path to the directory containing an asset file
     * @default ""
     */
    u?: string;
    /**
     * Filename or Data URL
     */
    p: string;
    /**
     * Embedded
     *
     * Whether the asset is embedded
     * @default 0
     */
    e?: Helpers.IntegerBoolean;
  }

  /**
   * External image
   */
  interface Image extends File {
    /**
     * Width of the image
     * @default 0
     */
    w?: Helpers.Width;
    /**
     *
     * Height of the image
     * @default 0
     */
    h?: Helpers.Height;
    /**
     * Type
     * Marks as part of an image sequence if present
     */
    t?: "seq";
  }

  /**
   * External sound
   */
  interface Sound extends File {}

  /**
   * Asset containing an animation that can be referenced by layers.
   */
  interface Precomposition
    extends Main,
      Composition,
      Helpers.MatchName,
      Helpers.Framerate {
    /**
     * Extra
     *
     * Extra composition
     * @default 0
     */
    xt?: Helpers.IntegerBoolean;
  }

  /**
   * External data source, usually a JSON file"
   */
  interface DataSource extends File {
    /**
     * Type
     * @type integer
     */
    t: 3;
  }

  type Value = Image | Precomposition | Sound | DataSource;
}

export {
  AnimatedProperty,
  Animation,
  Asset,
  BlendMode,
  Composite,
  Composition,
  Effect,
  EffectType,
  EffectValue,
  EffectValueType,
  FillRule,
  GradientType,
  Helpers,
  Layer,
  LayerStyleType,
  LayerType,
  LineCap,
  LineJoin,
  Marker,
  MaskMode,
  MatteMode,
  Metadata,
  MotionBlur,
  PolyStarType,
  Shape,
  ShapeDirection,
  ShapeType,
  StrokeDashType,
  Style,
  Text,
  TextType,
  TrimMultipleShapes,
};
